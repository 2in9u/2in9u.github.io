---
#layout: posts
excerpt: ""
title: "[C++] ğŸ“‚. vector<T> ì‹¤ìŠµ"

categories:
    - cpp
# tag:
#     [cpp, c++, oop]

toc_label: "ëª©ì°¨"
toc: true
toc_sticky: true

date: 2022-09-18
last_modified_at: 2022-09-18
---

# my_vector<T>
```c++
#include <iostream>
using namespace std;

template <typename T>
class my_vector
{
public:
	my_vector()
	{
	}

	~my_vector()
	{
		if (_data)
			delete[] _data;
	}

	// capacityì™€ sizeì˜ ê°’ì´ ê°™ë‹¤ë©´ capacityë¥¼ 1.5ë°° ì¦ê°€ ì‹œí‚¨ë‹¤.
	// ë§¨ ë’¤ì— value ê°’ì„ ì¶”ê°€í•œë‹¤.
	void push_back(const T& value)
	{
		if (_size == _capacity)
		{
			int newCapacity = static_cast<int>(_capacity * 1.5);
			if (_size == newCapacity)
				++newCapacity;

			reserve(newCapacity);
		}

		_data[_size++] = value;
	}

	void pop_back()
	{
		--_size;
	}

	// í˜„ì¬ capacityì´í•˜ë©´ ë™ì‘ ì•ˆí•¨
	// í˜„ì¬ capacityë¥¼ ë³€ê²½í•˜ê³  ìƒˆë¡œìš´ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹ë°›ì•„ ì›ì†Œë¥¼ ë³µì‚¬
	void reserve(int capacity)
	{
		if (capacity <= _capacity)
			return;

		SetCapacity(capacity);		
	}

	// ëª¨ë“  ì›ì†Œ ì‚­ì œ
	// capacityë§Œí¼ ê³µê°„ ìœ ì§€
	// size ê°’ 0
	void clear()
	{
		if (_data)
		{
			delete[] _data;
			_data = new T[_capacity];	// allocator c++ ì•Œì•„ë³´ê¸°
		}

		_size = 0;
	}

	// sizeì— ë§ê²Œ capacity ìˆ˜ì •
	void shrink_to_fit()
	{
		SetCapacity(_size);
	}

	// Random Access ê°€ëŠ¥
	T& operator[](const int pos) { return _data[pos]; }

	// ë§¨ ì• ì›ì†Œ
	T& front() { return _data[0]; }
	// ë§¨ ë’¤ ì›ì†Œ
	T& back() { return _data[_size - 1]; }

	// ê°’ì´ ì—†ëŠ” ê²½ìš° íŒë³„
	bool empty() { return _size == 0; }

	int size() { return _size; }
	int capacity() { return _capacity; }

private:
	void SetCapacity(int capacity)
	{
		_capacity = capacity;

		T* newData = new T[_capacity];

		// ë©”ëª¨ë¦¬ ì´ë™ ë° ë³µì‚¬
		for (int i = 0; i < _size; ++i)
			newData[i] = _data[i];

		if (_data)
			delete[] _data;

		_data = newData;
	}

private:
	T*	_data = nullptr;
	int _size = 0;
	int _capacity = 0;
};
```