---
#layout: posts
excerpt: ""
title: "[C++] 📂. vector<T> 실습"

categories:
    - cpp
# tag:
#     [cpp, c++, oop]

toc_label: "목차"
toc: true
toc_sticky: true

date: 2022-09-18
last_modified_at: 2022-09-18
---

# my_vector<T>
```c++
#include <iostream>
using namespace std;

template <typename T>
class my_vector
{
public:
	my_vector()
	{
	}

	~my_vector()
	{
		if (_data)
			delete[] _data;
	}

	// capacity와 size의 값이 같다면 capacity를 1.5배 증가 시킨다.
	// 맨 뒤에 value 값을 추가한다.
	void push_back(const T& value)
	{
		if (_size == _capacity)
		{
			int newCapacity = static_cast<int>(_capacity * 1.5);
			if (_size == newCapacity)
				++newCapacity;

			reserve(newCapacity);
		}

		_data[_size++] = value;
	}

	void pop_back()
	{
		--_size;
	}

	// 현재 capacity이하면 동작 안함
	// 현재 capacity를 변경하고 새로운 메모리를 할당받아 원소를 복사
	void reserve(int capacity)
	{
		if (capacity <= _capacity)
			return;

		SetCapacity(capacity);		
	}

	// 모든 원소 삭제
	// capacity만큼 공간 유지
	// size 값 0
	void clear()
	{
		if (_data)
		{
			delete[] _data;
			_data = new T[_capacity];	// allocator c++ 알아보기
		}

		_size = 0;
	}

	// size에 맞게 capacity 수정
	void shrink_to_fit()
	{
		SetCapacity(_size);
	}

	// Random Access 가능
	T& operator[](const int pos) { return _data[pos]; }

	// 맨 앞 원소
	T& front() { return _data[0]; }
	// 맨 뒤 원소
	T& back() { return _data[_size - 1]; }

	// 값이 없는 경우 판별
	bool empty() { return _size == 0; }

	int size() { return _size; }
	int capacity() { return _capacity; }

private:
	void SetCapacity(int capacity)
	{
		_capacity = capacity;

		T* newData = new T[_capacity];

		// 메모리 이동 및 복사
		for (int i = 0; i < _size; ++i)
			newData[i] = _data[i];

		if (_data)
			delete[] _data;

		_data = newData;
	}

private:
	T*	_data = nullptr;
	int _size = 0;
	int _capacity = 0;
};
```