---
#layout: posts
excerpt: ""
title: "[DirectX12] ğŸ“‚. Camera"
categories:
    - dx12
# tag:
# Â  Â  [cpp, c++, oop]
toc_label: "ëª©ì°¨"
toc: true
toc_sticky: true
date: 2023-02-19
last_modified_at: 2023-02-19

#published: false
---

> DirectXTKì˜ [SimpleMath](https://github.com/microsoft/DirectXTK12)ë¥¼ í™œìš©í•˜ì—¬ í”„ë¡œì íŠ¸ ì§„í–‰  
> - DXë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¶”ê°€ì  ìˆ˜í•™í•¨ìˆ˜ë¥¼ ì œê³µí•œë‹¤.  
> ![image](../../assets/images/dx12_img/13_camera/simple_math.png)

<br>

# ğŸ”· Camera
- ì¹´ë©”ë¼ê°€ ë³´ëŠ” ì‹œì•¼ì˜ ê²°ê³¼ë¬¼ì„ ë§Œë“ ë‹¤.

<br>

## 1. Camera
### 1.1. Camera Class
- ì¹´ë©”ë¼ì˜ ê´€ì ìœ¼ë¡œ ì¢Œí‘œë¥¼ ì˜®ê¸°ëŠ” ViewMatrixì™€ ì¹´ë©”ë¼ê°€ ë³´ëŠ” ì¥ë©´ìœ¼ë¡œ ì¢Œí‘œë¥¼ ì˜®ê¸°ëŠ” ProjectionMatrixë¥¼ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤
- ì¹´ë©”ë¼ì˜ íˆ¬ì˜ì€ ì›ê·¼ íˆ¬ì˜ê³¼, ì§êµ íˆ¬ì˜ìœ¼ë¡œ ë‚˜ëˆˆë‹¤.

```cpp
enum class PROJECTION_TYPE
{
	PERSPECTIVE,    // ì›ê·¼ íˆ¬ì˜
	ORTHOGRAPHIC,   // ì§êµ íˆ¬ì˜
};
```

```cpp
class Camera : public Component
{
...
private:
	PROJECTION_TYPE	_type = PROJECTION_TYPE::PERSPECTIVE;
	
	float			_near = 1.f;        // ì ˆë‘ì²´ì˜ ê°€ì¥ ê°€ê¹Œìš´ ë©´ì˜ ê±°ë¦¬
	float			_far = 1000.f;      // ì ˆë‘ì²´ì˜ ê°€ì¥ ë¨¼ ë©´ì˜ ê±°ë¦¬
	float			_fov = XM_PI / 4.f; // ì¹´ë©”ë¼ ì‹œì•¼ ê°ë„
	float			_scale = 1.f;       // ì§êµíˆ¬ì˜ì—ì„œ ì‚¬ìš©

	Matrix			_matView = {};          // ë·° í–‰ë ¬
	Matrix			_matProjection = {};    // íˆ¬ì˜ í–‰ë ¬
};
```

1) ì¹´ë©”ë¼ì˜ ë·°í–‰ë ¬ê³¼ íˆ¬ì˜ í–‰ë ¬ì„ êµ¬í•œë‹¤.

```cpp
// ë·° í–‰ë ¬
_matView = GetGameObject()->GetTransform()->GetLocalToWorldMatrix().Invert();

float width = static_cast<float>(MyEngine->GetWindow().width);
float height = static_cast<float>(MyEngine->GetWindow().height);

// íˆ¬ì˜ í–‰ë ¬
if (_type == PROJECTION_TYPE::PERSPECTIVE)
    _matProjection = ::XMMatrixPerspectiveFovLH(_fov, width / height, _near, _far);
else
    _matProjection = ::XMMatrixOrthographicLH(width * _scale, height * _scale, _near, _far);
```

2) í™œì„±í™” ëœ Sceneì˜ GameObjectë“¤ì„ ì¹´ë©”ë¼ì˜ ê´€ì ì—ì„œ ë Œë”ë§í•œë‹¤.

```cpp
shared_ptr<Scene> scene = SceneManager::GetInstance()->GetActiveScene();

// TODO : Layer êµ¬ë¶„
const vector<shared_ptr<GameObject>>& gameObjects = scene->GetGameObjects();

for (auto& gameObject : gameObjects)
{
    if (gameObject->GetMeshRenderer() == nullptr)
        continue;

    GetGameObject()->GetTransform()->PushData();
	gameObject->GetMeshRenderer()->Render();
}
```

<br>

### 1.2. KeyInputScript Class
- í‚¤ë³´ë“œ ì…ë ¥ì— ë”°ë¥¸ Transformì„ ë³€ê²½í•˜ëŠ” ë™ì‘ì„ í•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸ 

```cpp
shared_ptr<Transform> transform = GetGameObject()->GetTransform();
Vec3 pos = transform->GetLocalPosition();

float deltaTime = Timer::GetInstance()->GetDeltaTime();

if (Input::GetInstance()->IsButtonPress(KEY_TYPE::W)) 	// ì•
	pos += transform->GetLook() * _speed * deltaTime;

if (Input::GetInstance()->IsButtonPress(KEY_TYPE::S))	// ë’¤
	pos -= transform->GetLook() * _speed * deltaTime;

if (Input::GetInstance()->IsButtonPress(KEY_TYPE::A))	// ì™¼ìª½
	pos -= transform->GetRight() * _speed * deltaTime;

if (Input::GetInstance()->IsButtonPress(KEY_TYPE::D))	// ì˜¤ë¥¸ìª½
	pos += transform->GetRight() * _speed * deltaTime;

if (Input::GetInstance()->IsButtonPress(KEY_TYPE::Q))	// íšŒì „(ìœ„)
{
	Vec3 rotation = transform->GetLocalRotation();
	rotation.x -= deltaTime * 0.5f;
	transform->SetLocalRotation(rotation);
}

if (Input::GetInstance()->IsButtonPress(KEY_TYPE::E))	// íšŒì „(ì•„ë˜)
{
	Vec3 rotation = transform->GetLocalRotation();
	rotation.x += deltaTime * 0.5f;
	transform->SetLocalRotation(rotation);
}

transform->SetLocalPosition(pos);
```

<br>

## 2. Component íŒŒìƒ í´ë˜ìŠ¤ êµ¬ì²´í™”

### 2.1. Transform Class
- Localì˜ Position, Rotation, Scaleì— ê´€í•œ ë²¡í„°ê°’, Local, Worldí–‰ë ¬ì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤

```cpp
class Transform : public Component
{
...
private:
	weak_ptr<Transform>	_parent;    // í˜„ì¬ ê°ì œì˜ ì¢Œí‘œì— ê¸°ì¤€ì´ ë˜ëŠ” Transform

	Vec3				_localPosition = {};
	Vec3				_localRotation = {};
	Vec3				_localScale = { 1.f, 1.f, 1.f };

	Matrix				_matLocal = {};
	Matrix				_matWorld = {};
};
```

1) ë³€ê²½ë˜ëŠ” ê°’ì— ë”°ë¼ SRTê°’ê³¼ Local, Worldí–‰ë ¬ ê°’ì„ ê°±ì‹ í•œë‹¤.

```cpp
Matrix matScale = Matrix::CreateScale(_localScale);                     // S
Matrix matRotation = Matrix::CreateRotationX(_localRotation.x);
matRotation *= Matrix::CreateRotationY(_localRotation.y);
matRotation *= Matrix::CreateRotationZ(_localRotation.z);               // R
Matrix matTranslation = Matrix::CreateTranslation(_localPosition);      // T

_matLocal = matScale * matRotation * matTranslation;
_matWorld = _matLocal;

shared_ptr<Transform> parent = GetParent().lock();
if (parent != nullptr)
    _matWorld += parent->GetLocalToWorldMatrix();
```

2) Transformì„ ê³„ì‚°í•˜ì—¬ CBV(b0)ë¡œ ë„˜ê²¨ì¤€ë‹¤.

```cpp
Matrix matWVP = _matWorld * matVP; // matVP :  ViewMatrix, ProjectionMatrixë¥¼ í•©ì„±í•œ ê°’
MyEngine->GetConstantBuffer(CONSTANT_BUFFER_TYPE::TRANSFORM)->PushData(&matWVP, sizeof(matWVP));
```

<br>

### 2.2. MeshRenderer Class
- ê¸°ì¡´ê³¼ ê°™ìŒ

<br>

## 3. HLSL

```cpp
cbuffer TRANSFORM_PARAMS : register(b0)
{
    row_major matrix matWVP;
}

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), matWVP); // ì¢Œí‘œë³€í™˜
    output.color = input.color;
    output.uv = input.uv;

    return output;
}
```

## ğŸ”¹ ê²°ê³¼  
![image](../../assets/images/dx12_img/13_camera/result.png)  

<br>

<br>

# ğŸ“‘. ì°¸ê³ 
* [Rookiss. [C++ê³¼ ì–¸ë¦¬ì–¼ë¡œ ë§Œë“œëŠ” MMORPG ê²Œì„ ê°œë°œ ì‹œë¦¬ì¦ˆ]Part2: ê²Œì„ ìˆ˜í•™ê³¼ DirectX12. Inflearn.](https://www.inflearn.com/course/%EC%96%B8%EB%A6%AC%EC%96%BC-3d-mmorpg-2/dashboard)
* [í”„ë­í¬ D. ë£¨ë‚˜(2020). DirectX 12ë¥¼ ì´ìš©í•œ 3Dê²Œì„ í”„ë¡œê·¸ë˜ë° ì…ë¬¸. í•œë¹›ë¯¸ë””ì–´(ì£¼).](https://www.hanbit.co.kr/store/books/look.php?p_code=B5088646371)